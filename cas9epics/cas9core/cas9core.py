"""
"""
from __future__ import division, print_function, unicode_literals

import declarative
from declarative import bunch

from . import reactor
from . import pcaspy_backend
#from . import relay_values


class ShadowBunchN(bunch.ShadowBunch):
    _names = {
        'full' :      0,
        'immed' :     1,
        'immediate' : 1,
        'prev' :      2,
        'previous' :  2,
    }


class ShadowBunchView(bunch.ShadowBunch):
    _names = {
        'new' :      0,
        'prev' :     1,
    }

class InstaCAS(
        pcaspy_backend.CASCollector,
        declarative.OverridableObject
):

    @declarative.dproperty
    def reactor(self):
        return reactor.Reactor()

    @declarative.dproperty
    def site(self, val = None):
        if val is None:
            val = 'X1'
        return val

    @declarative.dproperty
    def name(self, val = None):
        if val is None:
            val = 'TST'
        return val

    @declarative.dproperty
    def prefix(self, val = declarative.NOARG):
        if val is declarative.NOARG:
            val = self.name
        return val

    @declarative.dproperty
    def prefix_full(self):
        if self.prefix is None:
            default = ()
        else:
            default = (self.name,)
        val = self.ctree.setdefault('prefix', default)
        return val

    def prefix2channel(self, prefix):
        chn = '{0}:{1}-'.format(self.site, prefix[0]) + '_'.join(prefix[1:])
        chn = chn.upper()
        return chn

    def start(self):
        if self._db_generated is None:
            self._db_generated = self.cas_db_generate()
            self._cas_generated = pcaspy_backend.CADriverServer(self._db_generated, self.reactor)
            self._cas_generated.start()
            return True
        return False

    _db_generated = None
    _cas_generated = None
    def run(self, for_s = None, modulo_s = None, mtime_to = None):
        #TODO decide if arguments should change how stopping is done on errors
        self.start()

        if for_s is None and modulo_s is None and mtime_to is None:
            try:
                self.reactor.run_reactor()
            finally:
                self.stop()
        else:
            self.reactor.flush(
                for_s    = for_s,
                modulo_s = modulo_s,
                mtime_to = mtime_to,
            )
        return

    def stop(self):
        if self._db_generated is not None:
            self._cas_generated.stop()
            self._db_generated = None
            self._cas_generated = None

    @declarative.dproperty
    def root(self):
        return self

    @declarative.mproperty
    def ctree(self, arg = declarative.NOARG):
        #if it is a view (as generated by ctree_shadow), then extract only the new elements
        if isinstance(arg, ShadowBunchView):
            arg = arg.extractidx('new')

        about = bunch.DeepBunchSingleAssign()
        full = bunch.DeepBunchSingleAssign()
        immed = bunch.DeepBunchSingleAssign()
        dicts = [full, immed, ]

        #add in the argument one as the last
        if arg is not declarative.NOARG:
            dicts.append(arg)
        return ShadowBunchN(dicts, abdict = about)


class CASUser(declarative.OverridableObject):
    name_default = None

    @declarative.dproperty
    def parent(self, val):
        return val

    @declarative.dproperty
    def name(self, val = None):
        if val is None:
            val = self.name_default
        if val is None:
            raise RuntimeError("Must specify object name")
        return val

    @declarative.dproperty
    def prefix(self, val = declarative.NOARG):
        if val is declarative.NOARG:
            val = self.name
        return val

    @declarative.dproperty
    def prefix_full(self):
        if self.prefix is None:
            default = tuple(self.parent.prefix_full)
        else:
            default = tuple(self.parent.prefix_full) + (self.name,)
        val = self.ctree.setdefault('prefix', default)
        return val

    @declarative.dproperty
    def root(self):
        return self.parent.root

    @declarative.mproperty
    def reactor(self):
        return self.root.reactor

    @declarative.mproperty
    def ctree(self):
        return self.parent.ctree[self.name]

    def cas_host(self, rv, name = None, **kwargs):
        return self.root.cas_host(
            rv     = rv,
            name   = name,
            prefix = self.prefix_full,
            **kwargs
        )

dproperty = declarative.dproperty
mproperty = declarative.mproperty
__NOARG = declarative.utilities.unique_generator()

def dproperty_ctree(func = None, default = __NOARG):
    """
    automatically grabs the value from the ctree to pass along. The function should do the string conversion and validation
    """
    def deferred(func):
        if default is __NOARG:
            def superfunc(self, val):
                val = self.ctree.setdefault(
                    func.__name__, val,
                    about = func.__doc__,
                )
                return func(val)
        else:
            def superfunc(self, val = default):
                val = self.ctree.setdefault(
                    func.__name__, val,
                    about = func.__doc__,
                )
                return func(val)
        superfunc.__name__ = func.__name__
        superfunc.__doc__  = func.__doc__
        return declarative.dproperty(superfunc)
    if func is None:
        return deferred
    else:
        return deferred(func)

