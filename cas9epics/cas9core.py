"""
TODO, make a burt.req generator and a monitor.req generator, as well as a utility for merging monitor.reqs into a single SDF monitor.req file (and possibly restarting a soft SDF system)
"""
from __future__ import division, print_function, unicode_literals

import declarative
from declarative import bunch

from . import reactor
from . import cas
from . import relay_values


class ShadowBunchN(bunch.ShadowBunch):
    _names = {
        'full' :      0,
        'immed' :     1,
        'immediate' : 1,
        'prev' :      2,
        'previous' :  2,
    }


class ShadowBunchView(bunch.ShadowBunch):
    _names = {
        'new' :      0,
        'prev' :     1,
    }

class InstaCAS(
        cas.CASCollector,
        declarative.OverridableObject
):

    @declarative.dproperty
    def reactor(self):
        return reactor.Reactor()

    @declarative.dproperty
    def site(self, val = None):
        if val is None:
            val = 'X1'
        return val

    @declarative.dproperty
    def name(self, val = None):
        if val is None:
            val = 'TST'
        return val

    @declarative.dproperty
    def prefix(self, val = declarative.NOARG):
        if val is declarative.NOARG:
            val = self.name
        return val

    @declarative.dproperty
    def prefix_full(self):
        if self.prefix is None:
            default = ()
        else:
            default = (self.name,)
        val = self.ctree.setdefault('prefix', default)
        return val

    def prefix2channel(self, prefix):
        chn = '{0}:{1}-'.format(self.site, prefix[0]) + '_'.join(prefix[1:])
        chn = chn.upper()
        return chn

    def run(self):
        #TODO make a db generator
        db = self.cas_db_generate()
        with cas.CADriverServer(db, self.reactor):
            self.reactor.run_reactor()

    @declarative.dproperty
    def root(self):
        return self

    @declarative.mproperty
    def ctree(self, arg = declarative.NOARG):
        #if it is a view (as generated by ctree_shadow), then extract only the new elements
        if isinstance(arg, ShadowBunchView):
            arg = arg.extractidx('new')

        full = bunch.DeepBunchSingleAssign()
        immed = bunch.DeepBunchSingleAssign()
        dicts = [full, immed, ]

        #add in the argument one as the last
        if arg is not declarative.NOARG:
            dicts.append(arg)
        return ShadowBunchN(dicts)


class CASUser(declarative.OverridableObject):
    @declarative.dproperty
    def parent(self, val):
        return val

    @declarative.dproperty
    def name(self, val):
        return val

    @declarative.dproperty
    def prefix(self, val = declarative.NOARG):
        if val is declarative.NOARG:
            val = self.name
        return val

    @declarative.dproperty
    def prefix_full(self):
        if self.prefix is None:
            default = tuple(self.parent.prefix_full)
        else:
            default = tuple(self.parent.prefix_full) + (self.name,)
        val = self.ctree.setdefault('prefix', default)
        return val

    @declarative.dproperty
    def root(self):
        return self.parent.root

    @declarative.mproperty
    def reactor(self):
        return self.root.reactor

    @declarative.mproperty
    def ctree(self):
        return self.parent.ctree[self.name]

    def cas_host(self, rv, name = None, **kwargs):
        return self.root.cas_host(
            rv     = rv,
            name   = name,
            prefix = self.prefix_full,
            **kwargs
        )
